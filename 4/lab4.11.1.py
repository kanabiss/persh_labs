from random import randrange
import numpy as np		# Импортируем библиотеку numpy, и для краткости записи назовем ее np
# Если просто написать "import numpy", то во всех местах, где сейчас написано "np", нужно было бы написать "numpy"

nrows = 15	# Кол-во строк
ncolumns = 10	# Кол-во столбцов

a = np.array([[randrange(1, 20) for i in range(ncolumns)] for k in range(nrows)])
# Сложная для понимания строка, но, если рассмотреть все по отдельности, станет понятнее
# Скажем, что "[randrange(1, 20) for i in range(ncolumns)]" - это будет какая-то переменная t
# Тогда 7 строка примет следующий вид:
# a = np.array([t for k in range(nrows)])
# Синтаксис "[t for k in range(nrows)]" значит, что создастся одномерный массив длиной nrows и заполненный какими-то элементами t
# А что такое t?
# Это тоже генератор массива
# t - это "[randrange(1, 20) for i in range(ncolumns)]"
# randrange(low, high) - функция, которая возвращает число в диапозоне от low до high
# Именно в этом месте происходит присвоение значений каждому элементы двумерного массива
# [randrange(1, 20) for i in range(ncolumns)] -	создает одномерный массив заполненный случайными числами
# Если рассмотреть все вместе, тогда получается, что в первую ячейку одномерного массива вставляется другой одномерный массив состоящий из 10(т.к. ncolumns = 10) случайных чисел;
# во вторую ячейку первого одномерного массива вставляется другой одномерный массив состоящий из 10(т.к. ncolumns = 10) других случайниых чисел; и так это повторится 15 раз(т.к. nrows = 15)
# Вот инфа с какого-то сайта про двумерные массивы:
# Если говорить про создание не одномерного, а двумерного массива, то он в Python создаётся путём использования вложенных генераторов, и выглядит это так:
# [[0 for j in range(m)] for i in range(n)]

# И теперь функция np.array([[randrange(1, 20) for i in range(ncolumns)] for k in range(nrows)]) вернет нам массив библиотеки numpy

print(a)

temp = np.copy(a)	# Создаем копию ранее созданного массива, чтобы не махать себе мозги
avr = np.average(a, 1)	# Эта функция возвращает массив, состоящий из средних значений элементов для каждой строки
			# Нужно дать золотые лавры тому ебалаю, который писал теорию(которая, кстати, почти полностью спизжена с какого-то сайта)
			# Пушо я не ебу, как перваш-непрогер сможет посмотреть библиотечные функции, догадаться, что она может пригодиться и ее нужно использовать,
			# загуглить про нее и перевести с английского
ind_sorted = np.argsort(avr)
# Есть функция sort() - она сортирует непосредственно значения
# А функция argsort() сортирует индексы
# Допустим, есть какой-то массив: [10, 2, 4, 1]
# индекс = 0: значение = 10
# индекс = 1: значение = 2
# индекс = 2: значение = 4
# индекс = 3: значение = 1

# Функция sort() отсортирует его, и он будет выглядеть так: [1, 2, 4, 10]
# индекс = 0: значение = 1
# индекс = 1: значение = 2
# и т.д.

# Функция argsort() отсортирует индексы, что нам и нужно для того, чтобы отсортировать исходный двумерный массив
# Заметь, в 34 строке мы сортируем одномерный массив со средними значениями
# np.argsort([10, 2, 4, 1]) вернет массив:
# [3, 1, 2, 0]
# т.е. третий элемент исходного массива наименьший, действительно, все так: 1 меньше 2, 4 и 10
# второй элемент больше третьего, но меньше остальных: 2 больше 1, но меньше 4 и 10
# Мы имеем порядок индексов, при котором значения по этими индексам возрастают

# Теперь нужно лишь переставить элементы в исходном двумерном массиве в соответствии с полученным порядком индексов
# К примеру, получили следующий порядок: [2, 0, 1]
# Значит, элемент с индексом 2 должен быть первым
# Берем его из скопированного в 29 строке массива и вставляем его в исходный массив и так далее в цикле
# Мы создали переменную temp для того, чтобы можно было проводить манипуляции с данными, не боясь, что что-то перезапишем и потеряем
for i in range(nrows):
	a[i] = temp[ind_sorted[i]]

# Исходный двумерный массив мы уже отсортировали
# Для красивого вывода отсортируем и одномерный массив со средними значениями, и у нас получится все ровненько и соответственно
avr.sort()

# Теперь просто выводим это все
for i in range(nrows):
	print(avr[i], end=' :\t')	# Печатаем среднее значение для каждой строки
	for j in range(ncolumns):
		print(a[i][j], end="\t")	# Печатаем последовательно каждое значение строки
	print()	# Переход на новую строку
